---
title: "Vignette: Dealing with SPSS labels in R"
author: "Martin Chan"
date: "June 5, 2019"
output:                    # DO NOT CHANGE
  prettydoc::html_pretty:  # DO NOT CHANGE
    theme: cayman          # DO NOT CHANGE
    highlight: github      # DO NOT CHANGE
---

```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
library(prettyjekyll)
library(tidyverse)
# prettyjekyll::FormatPost("_knitr/SPSS_Labels_in_R_18-05-19.Rmd")
# servr::jekyll("../blog")
```

## Background

As survey data is pretty much unavoidable in my work, I'm always on the look out for new and better ways to improve my survey analysis workflow in R. Funnily enough, when I was first starting out to use R I didn't think R was at all intuitive or easy to work with survey data. Rather painful, if I'm completely honest!

One of the big reasons was due to survey labels. Most survey data cannot be analysed independently of the **variable** (e.g. *Q1. What is your gender?*) and **value labels** (e.g. 1 = **Male**, 2 = **Female**, 3 = **Other**, ...) - which is true in the case of **categorical variables**, but even for ordinal Likert scale variables like "On a scale of 1 to 10, how much do you agree with...", the meaning of the value is highly dependent on the nuanced wording of the agree-disagree statement; respondents with a different classification within the survey (e.g. "working professional" vs "retirees") may get a statement that is worded slightly differently. 

The base **data frame** in R does not easily lend itself to work easily with these labels. A lot of merging, sorting, recoding etc. therefore is then necessary in order to turn the analysis into neat output contingency tables that you typically get via other specialised survey analysis software, like SPSS or [Q](https://www.qresearchsoftware.com/), for example:

```{r echo=FALSE, message=FALSE, warning=FALSE}
tibble(`Q10 Top 2 Box Agree` = c("Coding R is one of my hobbies",
                                 "I don't like to spend time in front of the computer on weekends",
                                 "I would be inclined to quit my job if I couldn't use R for data analysis"),
       `R Users Segment` = c("88.1%","40.5%","70.1%"),
       `Python Users Segment` = c("60.0%","39.1%","40.5%"))
```

Of course, another big reason was my own ignorance of all the different methods and packages available out there at the time, which would have otherwise made a lot of this easier. 

This post provides a tour of the various functions (from different packages) that I wish I had known at the time. Despite the title, it's not just about **SPSS**: there are plenty of other formats (e.g. SAS files) out there which carry variable and value labels, but I think this title is justified because:

1. Most people starting out on survey data analysis will tend to first come across SPSS files (.sav) 
2. It's still one of the most popular data formats for survey data
3. It's a SPSS file that I will use as a demo in this post (perhaps not a compelling reason, but still a reason)

## Let's start!

Let us first load in all the packages that we'll use in this post. For clarity, I will still make the package-source of the functions explicit (e.g. `labelled::val_label()`) so it's easy to see where each function comes from. One of these packages  **surveytoolbox** is my own and available on Github only, and if you're interested you can install this by running `devtools::install_github("martinctc/surveytoolbox")`.

```{r message=FALSE, warning=FALSE, include=TRUE}
library(tidyverse)
library(haven)
library(sjlabelled)
library(labelled) 
library(surveytoolbox) # install with devtools::install_github("martinctc/surveytoolbox")
```

Since all I really needed is just an open-source, simple, and accessible SPSS / .sav dataset with variable and value labels that I could use for examples, I simply went online and found the first dataset that matched these criteria. Not the most exciting - it's the **1991 General Social Survey**, which is a nationally representative sample of adults in the United States. You can download the SAV file from the ARDA site [here](http://www.thearda.com/Archive/Files/Downloads/GSS1991_DL2.asp).

`haven::read_sav()` is my favourite way of loading in SPSS files. In my experience, it rarely has any problems and is generally fast enough; it is also part of the [tidyverse](https://haven.tidyverse.org/). There are other alternatives such as `sjlabelled::read_spss()` and `foreign::read.spss()`, but **haven** is my recommendation - you can pick a favourite and have these available in your backpocket.[^1] Note that `foreign::read.spss()` returns a list rather than a data frame or a tibble, which is less ideal.

```{r echo=TRUE, results = 'hide', message=FALSE, warning=FALSE}
file_path <- "../datasets/General Social Survey_1991.SAV"

source_data_hv <- haven::read_sav(file_path)
source_data_sj <- sjlabelled::read_spss(file_path)
source_data_fo <- foreign::read.spss(file_path)
```

Running `glimpse()` on the first twenty rows show that many variables are of the **labelled double** class - meaning that these variables would have labels associated with the numeric values they hold. The numbers alone us tell us nothing about what they represent, as these are likely to be categorical variables "in reality".

```{r echo=TRUE, results = "hide", message=FALSE, warning=FALSE}
source_data_hv %>% # File read in using `haven::read_sav()`
  .[,1:20] %>% # First 20 columns
  glimpse() 
```

Note that `haven::read_sav()` reads these labelled variables in as a class called `haven_labelled`, whilst `sjlabelled::read_spss()` would read these in as numeric variables cotaining label attributes.

Using **haven**:
```{r}
source_data_hv$MARITAL %>% class()

```
Using **sjlabelled**:
```{r}
source_data_sj$MARITAL %>% class()
```


Running `attr()` whilst specifying "labels" shows that both methods of reading the SPSS file return variables that contain value label attributes. Note that specifying "label**s**" (with an s) typically returns value labels, whereas "label" (no s) would return the variable labels. 

Using **haven**:
```{r}
source_data_hv$MARITAL %>% attr('labels')

```

Using **sjlabelled**:
```{r}
source_data_sj$MARITAL %>% attr('labels')
```


## Exploring the dataset

For the subsequent examples, I shall use the tibble read in with **haven** for simplicity.

Before you perform any analysis it's necessary to first explore what variables and variable codes (value labels) are available in the data, which is needed if you do not have the original questionnaire. Here are several of my favourite functions:

1. `sjPlot::view_df()`
2. `surveytoolbox::data_dict()`
3. `surveytoolbox::varl_tb()`

```{r eval=FALSE}
source_data_hv %>% sjPlot::view_df()
```

The `view_df()` function from the **sjPlot** package returns a pretty HTML document that, by default, contains a table that details the following for all the variables in the data:

- Variable name
- Variable label
- Value range / Values
- Value labels

Check out this link to see an example of what's generated with the function:

[LINK](https://martinctc.github.io/blog/_knitr/sjPlot_view_df.html)











[^1]: See [this](https://www.r-bloggers.com/working-with-spss-data-in-r/) blog post for a more in-depth discusssion on the differences 
